<hr />
<p>layout: post category : articles</p>

<h2 id='tags__rails_cucumber_capybara_rspec_turnip'>tags : <span>rails, cucumber, capybara, rspec, turnip</span></h2>

<p>Liquid error: No such file or directory - /Users/macbookpro/Sites/thenickcox.github.com/_posts/_includes</p>

<p>At work, we&#8217;ve been moving away from Cucumber tests for the past number of months, in favor of the more robust Capybara and rspec paring. Given that I&#8217;m a relative novice in Rails test-driven development, the supposed brittleness of Cucumber tests wasn&#8217;t immediately clear to me, so I did some digging, and came up with a <a href='http://aslakhellesoy.com/post/11055981222/the-training-wheels-came-off'>few</a> <a href='http://benmabey.com/2008/05/19/imperative-vs-declarative-scenarios-in-user-stories.html'>posts</a> that talk about the pitfalls of the &#8220;imperative&#8221; style of step writing for user stories. A solid example of this is Ben Mabey&#8217;s ancient, but still applicable post, <a href='http://benmabey.com/2008/05/19/imperative-vs-declarative-scenarios-in-user-stories.html'>&#8220;Imperative vs. Declarative Scenarios in User Stories&#8221;</a>. Mabey&#8217;s assertion is that it is too easy to rely too heavily on the built-in Cucumber web steps. For example: When I fill in Name with &#8216;Alligator&#8217; And select Phylum as &#8216;Chordata&#8217; And fill in Animal Class with &#8216;Sauropsida&#8217; And fill in Order with &#8216;Crocodilia&#8217; And fill in Family with &#8216;Alligatoridae&#8217; And fill in Genus with &#8216;Alligator&#8217; And check Lay Eggs And click the Create button Here, Maybe suggests, the &#8220;story&#8221; part of the user story tends to get lost and mired in the technical details. I was heavily influenced by this post, and decided to do a little Cucumber refactoring at work to try out Mabey&#8217;s declarative style, which he demonstrates thusly: Story: Animal Submission As a Zoologist I want to add a new animal to the site So that I can share my animal knowledge with the community Scenario: successful submission Given I&#8217;m on the animal creation page When I add a new animal Then I should see the page for my newly created animal And the notice &#8216;Thank you for your animal submission!&#8217; As Mabey notes, it has more of the <a href='http://www.jbrains.ca/permalink/user-stories-a-ticket-for-a-conversation'>token for conversation</a> feel to it, and it&#8217;s immediately clear that it is more likely to meet the user&#8217;s need, since, in this case, the user cares more about completing their goals than how those goals are handled on the back end.</p>

<h2 id='my_attempt'>My Attempt</h2>

<p>I took Mabey&#8217;s advice to our own codebase, and I extracted a Cucumber test that I had written a few months back. Now, I won&#8217;t start to bad mouth my code and talk endlessly about how terrible a person I am for having written it this way, but I&#8217;ll give you a taste of how poorly this test spoke to the user&#8217;s need. I present to you this feature test for our site&#8217;s feedback form: features/feedback.feature Feature: Feedback Scenario: Submitting feedback Given I go to the feedback page And I fill out the feedback form and submit it Then I should see a success message Then I should see &#8220;Email can&#8217;t be blank&#8221; When I fill in &#8220;Your email&#8221; with &#8220;nick@navigatingcancer.com&#8221; And I fill in &#8220;Summary&#8221; with &#8220;This site rules&#8221; And I fill in &#8220;What you observed&#8221; with &#8220;This site rules&#8221; And I press &#8220;Send&#8221; Then the flash notice should be &#8220;Thank you for your feedback! We try to respond to questions and requests within one business day.&#8221; And ruby FeedbackForm.last.email.should == &#8216;nick@navigatingcancer.com&#8217; And ruby FeedbackForm.last.content.should match &#8220;This site rules&#8221; Yep, you read that right. That&#8217;s a Ruby function inside of a Cucumber test. I wonder what user will be thinking of their form submission in terms of a Ruby method chain? Now here&#8217;s my improved version, written with Turnip and Capybara. #spec/acceptance/forms/feedback.feature&#8217; Feature: Feedback form As a user of the site I want to be able to submit feedback about the site So that I can report if something breaks @feedback Scenario: Submitting feedback (successful) Given I go to the feedback page And I fill out the feedback form and submit it Then I should see a success message</p>

<p>#spec/acceptance/forms/feedback_steps.rb require &#8216;spec_helper&#8217; steps_for :feedback do step &#8216;I go to the feedback page&#8217; do page.visit &#8216;/feedback&#8217; end step &#8216;I fill out the feedback form and submit it&#8217; do page.click_button &#8216;Send&#8217; page.should have_content &#8220;Email can&#8217;t be blank&#8221; page.fill_in &#8216;Your email&#8217;, with: &#8216;joe@navigatingcancer.com&#8217; page.fill_in &#8216;Summary&#8217;, with: &#8216;Just saying&#8217; page.fill_in &#8216;What you observed&#8217;, with: &#8216;I am awesome&#8217; page.click_button &#8216;Send&#8217; end step &#8216;I should see a success message&#8217; do page.should have_content &#8220;Thank you for your feedback! We try to respond to questions and requests within one business day.&#8221; FeedbackForm.last.email.should == &#8216;joe@navigatingcancer.com&#8217; FeedbackForm.last.content.should match &#8216;I am awesome&#8217; end end See how much more nicely that reads? Now the user story is really coherent. They go to the form and submit it, and they should get a success message. That&#8217;s truly how simple the step should be. Notice that I still handled the validation in Capybara. But the it&#8217;s not the user&#8217;s job to think about what should happen if they don&#8217;t submit the form correctly, it&#8217;s mine. Thus, I should handle that in the test logic that doesn&#8217;t involve the user story.</p>

<h2 id='onward'>Onward</h2>

<p>As a front-end developer coming to the TDD Rails world, Cucumber was helpful to me because it helped me to think about things from the browser&#8217;s perspective. The <a href='https://github.com/cucumber/cucumber/wiki/Gherkin'>gherkin syntax</a>, when used well, really does allow for expressive steps and user stories that invite collaboration with non-developers. But that syntax paired with Capybara&#8217;s more robust step handling make for a much clearer and well-executed test. Notably, the reason I went back to this test was that we had changed the UI for the form. Our previous form submitted an <a href='https://unfuddle.com/'>unfuddle</a> ticket, but we have recently switched our ticketing system to <a href='http://assembla.com'>Assembla</a>. Also, we added a few fields and renamed others. In this case, the Cucumber test (previous to the one I have posted) would have failed because it wouldn&#8217;t have been able to find the form labels it was looking for. <em>But the user story remained the same.</em> All the user wants to do is submit a feedback form. So rather than changing several tests to reflect this, why not only change the ones that are concerned on the back end? They&#8217;re easier to maintain, and as great as Cucumber was, I find that I prefer the Capybara-rspec approach when it comes to looking for content on the page. I&#8217;m looking forward to exploring this technique across our codebase during refactoring, and in the future.</p>